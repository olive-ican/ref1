<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/legacy/controller/PromotionViewController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/legacy/controller/PromotionViewController.java" />
              <option name="originalContent" value="package com.example.legacy.controller;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;&#10;@Controller&#10;@RequiredArgsConstructor&#10;public class PromotionViewController {&#10;&#10;    /**&#10;     * 루트 경로(&quot;/&quot;)로 접근 시 프로모션 목록 페이지를 반환합니다.&#10;     * &quot;promotions.html&quot; 템플릿을 렌더링합니다.&#10;     * @return 프로모션 뷰 페이지의 논리적 이름&#10;     */&#10;    @GetMapping(&quot;/&quot;)&#10;    public String getPromotionsPage() {&#10;        return &quot;promotions&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.legacy.controller;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;&#10;@Controller&#10;@RequiredArgsConstructor&#10;public class PromotionViewController {&#10;&#10;    /**&#10;     * 루트 경로(&quot;/&quot;)로 접근 시 프로모션 목록 페이지를 반환합니다.&#10;     * &quot;promotions.html&quot; 템플릿을 렌더링합니다.&#10;     * @return 프로모션 뷰 페이지의 논리적 이름&#10;     */&#10;    @GetMapping(&quot;/&quot;)&#10;    public String getPromotionsPage() {&#10;        return &quot;promotions&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/legacy/repository/PromotionRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/legacy/repository/PromotionRepository.java" />
              <option name="originalContent" value="package com.example.legacy.repository;&#10;&#10;import com.example.legacy.model.Promotion;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.example.legacy.dto.PromotionResponseDto;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface PromotionRepository extends JpaRepository&lt;Promotion, Long&gt; {&#10;&#10;    /*&#10;     * 기존 쿼리:&#10;     * SELECT * FROM ( SELECT A.PROD_CD, A.PROD_NM, B.PROMO_PRICE, B.START_DT, B.END_DT FROM TB_PRODUCT A, TB_PROMOTION B WHERE A.PROD_CD = B.PROD_CD AND A.USE_YN = 'Y' ) WHERE TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN START_DT AND END_DT&#10;     *&#10;     * 튜닝된 JPQL 쿼리 설명:&#10;     * 1. `TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN START_DT AND END_DT` 대신 `p.startDt &lt;= CURRENT_DATE AND p.endDt &gt;= CURRENT_DATE`를 사용합니다.&#10;     *    이는 데이터베이스의 날짜 컬럼에 인덱스가 있을 경우, `TO_CHAR` 함수 사용으로 인한 인덱스 무효화를 방지하고 인덱스 레인지 스캔을 유도하여 성능을 향상시킵니다.&#10;     * 2. `JOIN p.product pr`은 JPA 엔티티 관계를 활용한 명시적인 조인으로, 가독성과 유지보수성을 높입니다.&#10;     *&#10;     * 참고:&#10;     * 정확한 테이블 레이아웃(컬럼 타입, 인덱스 유무)과 데이터 분포를 알 수 없으므로, 이 튜닝은 일반적으로 성능 개선에 도움이 되는 수준입니다.&#10;     * 최적의 튜닝을 위해서는 실제 데이터베이스 환경에서의 실행 계획 분석이 필수적입니다.&#10;     */&#10;    @Query(&quot;SELECT new com.example.legacy.dto.PromotionResponseDto(&quot; +&#10;           &quot;  p.product.prodCd, p.product.prodNm, p.promoPrice, p.startDt, p.endDt) &quot; +&#10;           &quot;FROM Promotion p &quot; +&#10;           &quot;JOIN p.product pr &quot; +&#10;           &quot;WHERE pr.useYn = 'Y' &quot; +&#10;           &quot;AND p.startDt &lt;= CURRENT_DATE &quot; +&#10;           &quot;AND p.endDt &gt;= CURRENT_DATE&quot;)&#10;    List&lt;PromotionResponseDto&gt; findCurrentPromotions();&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.legacy.repository;&#10;&#10;import com.example.legacy.model.Promotion;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.data.jpa.repository.Query;&#10;import org.springframework.stereotype.Repository;&#10;import com.example.legacy.dto.PromotionResponseDto;&#10;&#10;import java.util.List;&#10;&#10;@Repository&#10;public interface PromotionRepository extends JpaRepository&lt;Promotion, Long&gt; {&#10;&#10;    /*&#10;     * 기존 쿼리:&#10;     * SELECT * FROM ( SELECT A.PROD_CD, A.PROD_NM, B.PROMO_PRICE, B.START_DT, B.END_DT FROM TB_PRODUCT A, TB_PROMOTION B WHERE A.PROD_CD = B.PROD_CD AND A.USE_YN = 'Y' ) WHERE TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN START_DT AND END_DT&#10;     *&#10;     * 튜닝된 JPQL 쿼리 설명:&#10;     * 1. `TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN START_DT AND END_DT` 대신 `p.startDt &lt;= CURRENT_DATE AND p.endDt &gt;= CURRENT_DATE`를 사용합니다.&#10;     *    이는 데이터베이스의 날짜 컬럼에 인덱스가 있을 경우, `TO_CHAR` 함수 사용으로 인한 인덱스 무효화를 방지하고 인덱스 레인지 스캔을 유도하여 성능을 향상시킵니다.&#10;     * 2. `JOIN p.product pr`은 JPA 엔티티 관계를 활용한 명시적인 조인으로, 가독성과 유지보수성을 높입니다.&#10;     *&#10;     * 참고:&#10;     * 정확한 테이블 레이아웃(컬럼 타입, 인덱스 유무)과 데이터 분포를 알 수 없으므로, 이 튜닝은 일반적으로 성능 개선에 도움이 되는 수준입니다.&#10;     * 최적의 튜닝을 위해서는 실제 데이터베이스 환경에서의 실행 계획 분석이 필수적입니다.&#10;     */&#10;    @Query(&quot;SELECT new com.example.legacy.dto.PromotionResponseDto(&quot; +&#10;           &quot;  p.product.prodCd, p.product.prodNm, p.promoPrice, p.startDt, p.endDt) &quot; +&#10;           &quot;FROM Promotion p &quot; +&#10;           &quot;JOIN p.product pr &quot; +&#10;           &quot;WHERE pr.useYn = 'Y' &quot; +&#10;           &quot;AND p.startDt &lt;= CURRENT_DATE &quot; +&#10;           &quot;AND p.endDt &gt;= CURRENT_DATE&quot;)&#10;    List&lt;PromotionResponseDto&gt; findCurrentPromotions();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>