<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Legacy Promotion Service&#10;&#10;## 프로젝트 개요&#10;&#10;이 프로젝트는 현재 진행 중인 상품 프로모션 정보를 조회하는 간단한 Spring Boot 애플리케이션입니다. 레거시 시스템의 프로모션 조회 로직을 현대적인 Spring Data JPA와 RESTful API 형태로 구현하고, 성능 튜닝을 고려하여 개발되었습니다.&#10;&#10;## 기술 스택&#10;&#10;*   **언어**: Java 17&#10;*   **프레임워크**: Spring Boot 3.x&#10;*   **데이터베이스**: H2 Database (인메모리)&#10;*   **ORM**: Spring Data JPA&#10;*   **빌드 도구**: Maven&#10;*   **템플릿 엔진**: Thymeleaf&#10;*   **캐싱**: Spring Cache (기본 설정)&#10;&#10;## 기능&#10;&#10;*   현재 날짜를 기준으로 활성화된 프로모션 목록 조회&#10;*   RESTful API를 통한 프로모션 데이터 제공&#10;*   웹 페이지를 통한 프로모션 목록 시각화&#10;&#10;## 설정 및 실행 방법&#10;&#10;1.  **프로젝트 클론**: Git 저장소에서 프로젝트를 클론합니다.&#10;    ```bash&#10;    git clone &lt;repository-url&gt;&#10;    cd legacy&#10;    ```&#10;&#10;2.  **의존성 설치**: Maven을 사용하여 프로젝트 의존성을 다운로드합니다.&#10;    ```bash&#10;    mvn clean install&#10;    ```&#10;&#10;3.  **애플리케이션 실행**: Spring Boot 애플리케이션을 실행합니다.&#10;    ```bash&#10;    mvn spring-boot:run&#10;    ```&#10;    또는 IDE(IntelliJ IDEA, Eclipse 등)에서 `LegacyApplication.java`를 실행합니다.&#10;&#10;4.  **접속**: 애플리케이션이 성공적으로 실행되면 다음 URL로 접속할 수 있습니다.&#10;    *   **웹 페이지**: `http://localhost:8080/`&#10;    *   **API 엔드포인트**: `http://localhost:8080/api/v1/promotions`&#10;&#10;## API 엔드포인트&#10;&#10;### `GET /api/v1/promotions`&#10;&#10;현재 날짜를 기준으로 활성화된 모든 프로모션 목록을 조회합니다.&#10;&#10;*   **응답**: `List&lt;PromotionResponseDto&gt;`&#10;&#10;    ```json&#10;    [&#10;      {&#10;        &quot;prodCd&quot;: &quot;P001&quot;,&#10;        &quot;prodNm&quot;: &quot;상품명1&quot;,&#10;        &quot;promoPrice&quot;: 10000,&#10;        &quot;startDt&quot;: &quot;2025-01-01&quot;,&#10;        &quot;endDt&quot;: &quot;2025-12-31&quot;&#10;      },&#10;      // ...&#10;    ]&#10;    ```&#10;&#10;## 데이터베이스 스키마 (H2)&#10;&#10;`src/main/resources/schema.sql` 및 `src/main/resources/data.sql` 파일을 통해 초기 스키마 및 데이터가 설정됩니다.&#10;&#10;*   **TB_PRODUCT**: 상품 정보 테이블&#10;    *   `PROD_CD` (VARCHAR): 상품 코드 (PK)&#10;    *   `PROD_NM` (VARCHAR): 상품명&#10;    *   `USE_YN` (CHAR): 사용 여부 (Y/N)&#10;&#10;*   **TB_PROMOTION**: 프로모션 정보 테이블&#10;    *   `PROMO_ID` (BIGINT): 프로모션 ID (PK)&#10;    *   `PROD_CD` (VARCHAR): 상품 코드 (FK, TB_PRODUCT 참조)&#10;    *   `PROMO_PRICE` (DECIMAL): 프로모션 가격&#10;    *   `START_DT` (DATE): 프로모션 시작일&#10;    *   `END_DT` (DATE): 프로모션 종료일&#10;&#10;## 튜닝 고려사항&#10;### 상황 가정&#10;START&#10;&#10;### [AS-IS 쿼리 및 문제점]&#10;&#10;```sql&#10;SELECT ... FROM TB_PRODUCT A, TB_PROMOTION B ...&#10;WHERE TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN START_DT AND END_DT&#10;```&#10;&#10;*   **문제 1**: Inline View 사용으로 인한 비효율 (옵티마이저가 뷰 병합을 못할 경우 전체 데이터 조인 후 필터링)&#10;*   **문제 2**: `TO_CHAR` 변환 등 DB 함수 의존 및 암시적 조인 사용으로 가독성 저하&#10;&#10;### [TO-BE 튜닝 포인트]&#10;&#10;1.  **바인딩 변수(:today) 사용**:&#10;    *   레거시 DB의 날짜 컬럼(`START_DT`, `END_DT`)이 `VARCHAR('YYYYMMDD')` 형식이므로, DB 함수 `TO_CHAR`를 사용하여 날짜를 변환하면 해당 컬럼에 생성된 인덱스를 활용할 수 없게 됩니다(Full Table Scan 발생). 이를 방지하기 위해 JPQL의 `CURRENT_DATE`(Date 타입) 대신 Java 애플리케이션 단에서 `LocalDate.now().format(&quot;yyyyMMdd&quot;)`와 같이 동일한 포맷의 `String` 파라미터(`:today`)를 생성하여 넘겨줍니다. 이로써 DB에서는 `String` vs `String` 비교가 이루어져 '타입 불일치로 인한 인덱스 미사용'을 방지하고 인덱스 레인지 스캔을 통해 성능을 향상시킵니다.&#10;2.  **명시적 JOIN (Standard Join)**:&#10;    *   JPA 엔티티 연관관계를 활용한 `JOIN pm.product p` 구문으로 변경하여 가독성을 높이고, 불필요한 카테시안 곱 발생 가능성을 차단하며 JPA 표준에 부합합니다.&#10;3.  **쿼리 구조 개선 (Flat Query)**:&#10;    *   서브쿼리를 제거하고 `WHERE` 절에서 날짜 범위를 직접 필터링하여, DB 옵티마이저가 날짜 인덱스를 통해 대상 범위를 먼저 좁히고(Driving) 조인을 수행하도록 유도합니다.&#10;&#10;**현재 EXPLAIN 결과 및 추가 고려사항**:&#10;제공된 `EXPLAIN` 결과에서 `TB_PROMOTION` 테이블의 `START_DT`, `END_DT` 컬럼에 대한 인덱스(`IDX_PROMOTION_DATES`)가 명시적으로 사용되지 않는 것으로 보입니다. 이는 주로 다음과 같은 이유 때문일 수 있습니다:&#10;*   **데이터 양 부족**: H2 데이터베이스는 데이터 양이 적을 경우(현재 테스트 데이터는 약 300건), 인덱스 스캔보다 전체 테이블 스캔이 더 효율적이라고 판단하여 인덱스를 사용하지 않을 수 있습니다.&#10;*   **옵티마이저의 선택**: 복합 인덱스(`START_DT`, `END_DT`)에 두 컬럼 모두 범위 조건이 걸려 있을 때, H2 옵티마이저가 인덱스를 최적으로 활용하지 않거나, 다른 조인 조건과 함께 고려하여 전체적인 비용이 더 낮은 실행 계획을 선택할 수 있습니다.&#10;&#10;**인덱스 활용 확인 방법**:&#10;*   `data.sql`에 훨씬 더 많은 프로모션 데이터를 삽입하여 인덱스 스캔이 유리하도록 만든 후 `EXPLAIN`을 다시 확인합니다.&#10;*   H2 콘솔에서 `EXPLAIN SELECT PROMO_ID, START_DT, END_DT FROM TB_PROMOTION WHERE START_DT &lt;= '20251217' AND END_DT &gt;= '20251217';`와 같이 조인 없이 날짜 조건만으로 쿼리를 실행하여 인덱스 활용 여부를 확인합니다.&#10;&#10;### 오라클에서 변경 시, TO-BE 쿼리 예시&#10;```sql&#10;SELECT A.PROD_CD,&#10;       A.PROD_NM,&#10;       B.PROMO_PRICE,&#10;       B.START_DT,&#10;       B.END_DT&#10;FROM TB_PRODUCT A&#10;INNER JOIN TB_PROMOTION B&#10;    ON A.PROD_CD = B.PROD_CD&#10;WHERE A.USE_YN = 'Y'&#10;  -- [정답] 우변이 문자열이므로, 좌변도 문자열로 맞춰줍니다.&#10;  AND TO_CHAR(SYSDATE, 'YYYYMMDD') &gt;= B.START_DT &#10;  AND TO_CHAR(SYSDATE, 'YYYYMMDD') &lt;= B.END_DT;&#10;```&#10;&#10;**최적의 튜닝을 위해서는 실제 데이터베이스 환경에서의 테이블 레이아웃(컬럼 타입, 인덱스 유무)과 데이터 분포를 기반으로 한 실행 계획 분석이 필수적입니다.**" />
              <option name="updatedContent" value="# Legacy Promotion Service&#10;&#10;## 프로젝트 개요&#10;&#10;이 프로젝트는 현재 진행 중인 상품 프로모션 정보를 조회하는 간단한 Spring Boot 애플리케이션입니다. 레거시 시스템의 프로모션 조회 로직을 현대적인 Spring Data JPA와 RESTful API 형태로 구현하고, 성능 튜닝을 고려하여 개발되었습니다.&#10;&#10;## 기술 스택&#10;&#10;*   **언어**: Java 17&#10;*   **프레임워크**: Spring Boot 3.x&#10;*   **데이터베이스**: H2 Database (인메모리)&#10;*   **ORM**: Spring Data JPA&#10;*   **빌드 도구**: Maven&#10;*   **템플릿 엔진**: Thymeleaf&#10;*   **캐싱**: Spring Cache (기본 설정)&#10;&#10;## 기능&#10;&#10;*   현재 날짜를 기준으로 활성화된 프로모션 목록 조회&#10;*   RESTful API를 통한 프로모션 데이터 제공&#10;*   웹 페이지를 통한 프로모션 목록 시각화&#10;&#10;## 설정 및 실행 방법&#10;&#10;1.  **프로젝트 클론**: Git 저장소에서 프로젝트를 클론합니다.&#10;    ```bash&#10;    git clone &lt;repository-url&gt;&#10;    cd legacy&#10;    ```&#10;&#10;2.  **의존성 설치**: Maven을 사용하여 프로젝트 의존성을 다운로드합니다.&#10;    ```bash&#10;    mvn clean install&#10;    ```&#10;&#10;3.  **애플리케이션 실행**: Spring Boot 애플리케이션을 실행합니다.&#10;    ```bash&#10;    mvn spring-boot:run&#10;    ```&#10;    또는 IDE(IntelliJ IDEA, Eclipse 등)에서 `LegacyApplication.java`를 실행합니다.&#10;&#10;4.  **접속**: 애플리케이션이 성공적으로 실행되면 다음 URL로 접속할 수 있습니다.&#10;    *   **웹 페이지**: `http://localhost:8080/`&#10;    *   **API 엔드포인트**: `http://localhost:8080/api/v1/promotions`&#10;&#10;## API 엔드포인트&#10;&#10;### `GET /api/v1/promotions`&#10;&#10;현재 날짜를 기준으로 활성화된 모든 프로모션 목록을 조회합니다.&#10;&#10;*   **응답**: `List&lt;PromotionResponseDto&gt;`&#10;&#10;    ```json&#10;    [&#10;      {&#10;        &quot;prodCd&quot;: &quot;P001&quot;,&#10;        &quot;prodNm&quot;: &quot;상품명1&quot;,&#10;        &quot;promoPrice&quot;: 10000,&#10;        &quot;startDt&quot;: &quot;2025-01-01&quot;,&#10;        &quot;endDt&quot;: &quot;2025-12-31&quot;&#10;      },&#10;      // ...&#10;    ]&#10;    ```&#10;&#10;## 데이터베이스 스키마 (H2)&#10;&#10;`src/main/resources/schema.sql` 및 `src/main/resources/data.sql` 파일을 통해 초기 스키마 및 데이터가 설정됩니다.&#10;&#10;*   **TB_PRODUCT**: 상품 정보 테이블&#10;    *   `PROD_CD` (VARCHAR): 상품 코드 (PK)&#10;    *   `PROD_NM` (VARCHAR): 상품명&#10;    *   `USE_YN` (CHAR): 사용 여부 (Y/N)&#10;&#10;*   **TB_PROMOTION**: 프로모션 정보 테이블&#10;    *   `PROMO_ID` (BIGINT): 프로모션 ID (PK)&#10;    *   `PROD_CD` (VARCHAR): 상품 코드 (FK, TB_PRODUCT 참조)&#10;    *   `PROMO_PRICE` (DECIMAL): 프로모션 가격&#10;    *   `START_DT` (VARCHAR(8)): 프로모션 시작일&#10;    *   `END_DT` (VARCHAR(8)): 프로모션 종료일&#10;&#10;## 튜닝 고려사항&#10;### 상황 가정&#10;START&#10;&#10;### [AS-IS 쿼리 및 문제점]&#10;&#10;```sql&#10;SELECT ... FROM TB_PRODUCT A, TB_PROMOTION B ...&#10;WHERE TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN START_DT AND END_DT&#10;```&#10;&#10;*   **문제 1**: Inline View 사용으로 인한 비효율 (옵티마이저가 뷰 병합을 못할 경우 전체 데이터 조인 후 필터링)&#10;*   **문제 2**: `TO_CHAR` 변환 등 DB 함수 의존 및 암시적 조인 사용으로 가독성 저하&#10;&#10;### [TO-BE 튜닝 포인트]&#10;&#10;1.  **바인딩 변수(:today) 사용**:&#10;    *   레거시 DB의 날짜 컬럼(`START_DT`, `END_DT`)이 `VARCHAR('YYYYMMDD')` 형식이므로, DB 함수 `TO_CHAR`를 사용하여 날짜를 변환하면 해당 컬럼에 생성된 인덱스를 활용할 수 없게 됩니다(Full Table Scan 발생). 이를 방지하기 위해 JPQL의 `CURRENT_DATE`(Date 타입) 대신 Java 애플리케이션 단에서 `LocalDate.now().format(&quot;yyyyMMdd&quot;)`와 같이 동일한 포맷의 `String` 파라미터(`:today`)를 생성하여 넘겨줍니다. 이로써 DB에서는 `String` vs `String` 비교가 이루어져 '타입 불일치로 인한 인덱스 미사용'을 방지하고 인덱스 레인지 스캔을 통해 성능을 향상시킵니다.&#10;2.  **명시적 JOIN (Standard Join)**:&#10;    *   JPA 엔티티 연관관계를 활용한 `JOIN pm.product p` 구문으로 변경하여 가독성을 높이고, 불필요한 카테시안 곱 발생 가능성을 차단하며 JPA 표준에 부합합니다.&#10;3.  **쿼리 구조 개선 (Flat Query)**:&#10;    *   서브쿼리를 제거하고 `WHERE` 절에서 날짜 범위를 직접 필터링하여, DB 옵티마이저가 날짜 인덱스를 통해 대상 범위를 먼저 좁히고(Driving) 조인을 수행하도록 유도합니다.&#10;&#10;**현재 EXPLAIN 결과 및 추가 고려사항**:&#10;제공된 `EXPLAIN` 결과에서 `TB_PROMOTION` 테이블의 `START_DT`, `END_DT` 컬럼에 대한 인덱스(`IDX_PROMOTION_DATES`)가 명시적으로 사용되지 않는 것으로 보입니다. 이는 주로 다음과 같은 이유 때문일 수 있습니다:&#10;*   **데이터 양 부족**: H2 데이터베이스는 데이터 양이 적을 경우(현재 테스트 데이터는 약 300건), 인덱스 스캔보다 전체 테이블 스캔이 더 효율적이라고 판단하여 인덱스를 사용하지 않을 수 있습니다.&#10;*   **옵티마이저의 선택**: 복합 인덱스(`START_DT`, `END_DT`)에 두 컬럼 모두 범위 조건이 걸려 있을 때, H2 옵티마이저가 인덱스를 최적으로 활용하지 않거나, 다른 조인 조건과 함께 고려하여 전체적인 비용이 더 낮은 실행 계획을 선택할 수 있습니다.&#10;&#10;**인덱스 활용 확인 방법**:&#10;*   `data.sql`에 훨씬 더 많은 프로모션 데이터를 삽입하여 인덱스 스캔이 유리하도록 만든 후 `EXPLAIN`을 다시 확인합니다.&#10;*   H2 콘솔에서 `EXPLAIN SELECT PROMO_ID, START_DT, END_DT FROM TB_PROMOTION WHERE START_DT &lt;= '20251217' AND END_DT &gt;= '20251217';`와 같이 조인 없이 날짜 조건만으로 쿼리를 실행하여 인덱스 활용 여부를 확인합니다.&#10;&#10;### 오라클에서 변경 시, TO-BE 쿼리 예시&#10;```sql&#10;SELECT A.PROD_CD,&#10;       A.PROD_NM,&#10;       B.PROMO_PRICE,&#10;       B.START_DT,&#10;       B.END_DT&#10;FROM TB_PRODUCT A&#10;INNER JOIN TB_PROMOTION B&#10;    ON A.PROD_CD = B.PROD_CD&#10;WHERE A.USE_YN = 'Y'&#10;  -- [정답] 우변이 문자열이므로, 좌변도 문자열로 맞춰줍니다.&#10;  AND TO_CHAR(SYSDATE, 'YYYYMMDD') &gt;= B.START_DT &#10;  AND TO_CHAR(SYSDATE, 'YYYYMMDD') &lt;= B.END_DT;&#10;```&#10;&#10;**최적의 튜닝을 위해서는 실제 데이터베이스 환경에서의 테이블 레이아웃(컬럼 타입, 인덱스 유무)과 데이터 분포를 기반으로 한 실행 계획 분석이 필수적입니다.**" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/legacy/controller/PromotionViewController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/legacy/controller/PromotionViewController.java" />
              <option name="originalContent" value="package com.example.legacy.controller;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;&#10;@Controller&#10;@RequiredArgsConstructor&#10;public class PromotionViewController {&#10;&#10;    /**&#10;     * 루트 경로(&quot;/&quot;)로 접근 시 프로모션 목록 페이지를 반환합니다.&#10;     * &quot;promotions.html&quot; 템플릿을 렌더링합니다.&#10;     * @return 프로모션 뷰 페이지의 논리적 이름&#10;     */&#10;    @GetMapping(&quot;/&quot;)&#10;    public String getPromotionsPage() {&#10;        return &quot;promotions&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.legacy.controller;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Controller;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;&#10;@Controller&#10;@RequiredArgsConstructor&#10;public class PromotionViewController {&#10;&#10;    /**&#10;     * 루트 경로(&quot;/&quot;)로 접근 시 프로모션 목록 페이지를 반환합니다.&#10;     * &quot;promotions.html&quot; 템플릿을 렌더링합니다.&#10;     * @return 프로모션 뷰 페이지의 논리적 이름&#10;     */&#10;    @GetMapping(&quot;/&quot;)&#10;    public String getPromotionsPage() {&#10;        return &quot;promotions&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>